#!/usr/bin/env rdmd
/**
 * qdmd.d - proof of concept build system for projects using qml.d
 *
 * qml.d is the second of two parts in a system to facilitate projects using
 * both qml and D. The first part is a compile-time binding generator, qml.d
 *
 * Usage: ./qdmd.d *.qml *.d
 *
 * Copyright
 * =========
 * Copyright (C) 2014 Josh Netterfield <joshua@netek.ca>
 * This work is free. You can redistribute it and/or modify it under the
 * terms of the Do What The Fuck You Want To Public License, Version 2,
 * as published by Sam Hocevar.  See http://www.wtfpl.net/ for more details.
 */

module qdmd;

import std.algorithm : any, findSplitAfter;
import std.conv : to;
import std.file : exists;
import std.path : absolutePath;
import std.process : execute, executeShell, pipeProcess, Redirect, wait;
import std.range : dropOne, drop, dropBack, dropBackOne;
import std.range : filter, map, retro, takeOne, array;
import std.stdio : File, stderr, writeln;
import std.string : endsWith, split, join, startsWith;

int main(string[] args) {
    assert(args.argumentsValid, "Usage: qdmd *.d *.qml");
    string[] files = args.dropOne() ~ "qdmd/qml.d";

    "mkdir -p .qdmd".executeShell;

    File(".qdmd/libappui.rcc", "w").write(
        "<!DOCTYPE RCC><RCC version=\"1.0\"><qresource>" ~
            (files
                .filter!(f => f.endsWith(".qml"))
                .map!(f =>
                    "<file alias=\"" ~
                        f
                            .split("/")
                            .retro
                            .takeOne
                            .join() ~
                    "\">../" ~ f ~ "</file>\n")()
            .join()) ~
        "</qresource></RCC>");

    File(".qdmd/libappui.cpp", "w").write(
        cppPrelude ~
        files
            .filter!(f => f.endsWith(".d"))
            .array
            .emitBindings);

    if ("libappui.pro.proto".exists) {
        "cp libappui.pro.proto .qdmd/libappui.pro"
            .executeShell;
    } else {
        File(".qdmd/libappui.pro", "w")
            .write(proPrelude);
    }

    auto qmake = "cd .qdmd; qmake && make".executeShell;
    qmake.output.writeln;
    assert(qmake.status == 0);

    return 0;
}

/**
 * Verifies that the arguments supplied are valid.
 */
@property bool argumentsValid(in string[] args) {
    return !args
        .dropOne()
        .any!(
            f => f.startsWith("-") || f.startsWith("\\") ||
                (!f.endsWith(".d") && !f.endsWith(".qml"))
            )();
}

/**
 * Given a list of files, compile the D source files, and return
 * cpp bindings.
 */
string emitBindings(string[] files) {
    string cpp;
    string mainCpp;

    auto pipes = (["dmd", "-I.", "-Isrc", "-Jsrc", "-J."] ~ files ~ ["-of.qdmd/dpart.o", "-c"])
        .pipeProcess(Redirect.stderr);

    string internalBindings;
    string mainBindings;
    foreach (line; pipes.stderr.byLine) {
        if (line.startsWith("@qdmd.cpp@ ")) {
            internalBindings ~= line.drop(11) ~ "\n";
        } else if (line.startsWith("@qdmd.cpp.main@ ")) {
            mainBindings ~= "    " ~ line.drop(15) ~ "\n";
        } else if (line.startsWith("@qdmd.rcc.import@ ")) {
            files ~= line
                .findSplitAfter("@qdmd.rcc.import@ ")
                    [1]
                .dropOne
                .dropBack(2)
                .split(", ")
                .map!(a => a.dropOne.dropBackOne)
                .map!(a => (a ~ ".qml").to!string().absolutePath)
                .filter!(a => a.exists)
                .array;
        } else {
            stderr.writeln(line);
        }
    }
    cpp ~= internalBindings;

    auto moc = ["moc"].pipeProcess(Redirect.stdout | Redirect.stdin);
    moc.stdin.write(cpp);
    moc.stdin.close();
    foreach (line; moc.stdout.byLine) {
        cpp ~= line ~ "\n";
    }

    cpp ~= q"[static int qdmd_argc = 1;
    static char qdmd_appname[] = {'q', 'd', 'm', 'd', 'A', 'p', 'p', 0};
    static char* qdmd_argv[] = {qdmd_appname};

    extern "C" void qdmd_main(const char* c_data) {
        DragonShim* s = new DragonShim();
        QByteArray data = c_data;
        QApplication* app = new QApplication(qdmd_argc, qdmd_argv);
        QQmlApplicationEngine* engine = new QQmlApplicationEngine(); ]" ~
        mainBindings ~ q"[
        engine->loadData(data);
        QObject *topLevel = engine->rootObjects().value(0);
        QQuickWindow *window = qobject_cast<QQuickWindow *>(topLevel);
        window->show();
        app->setQuitOnLastWindowClosed(false);
        QObject::connect(window, SIGNAL(closing(QQuickCloseEvent*)), app, SLOT(quit()));
        if (!window) {
            app->deleteLater();
        } else {
            app->exec();
        }
        return;
    }]";

    assert(!pipes.pid.wait, "Could not build d part");

    return cpp;
}

enum cppPrelude = q"{//Generated by qdmd
//Do not modify.
#include <QtCore/QDebug>
#include <QtCore/QJsonArray>
#include <QtCore/QJsonDocument>
#include <QtCore/QJsonObject>
#include <QtCore/QJsonValue>
#include <QtCore/QMap>
#include <QtGui/QGuiApplication>
#include <QtQml/QQmlApplicationEngine>
#include <QtQml/QQmlContext>
#include <QtQuick/QQuickItem>
#include <QtQuick/QQuickView>
#include <QtWidgets/QApplication>
}";

enum proPrelude = q"{#Generated by qdmd
#Do not modify.
#NOTE: To use your own template instead of this file,
#copy this file to "../libappui.pro.proto" and modify it.

DESTDIR = ..
TEMPLATE = lib
TARGET = appui
INCLUDEPATH += .
QT += quick widgets
SOURCES += libappui.cpp
RESOURCES += libappui.rcc
}";

